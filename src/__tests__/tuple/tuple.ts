import { existsSync, readFileSync, rmdirSync } from 'fs';
import Joi from 'joi';

import { convertFromDirectory, convertSchema } from '../../index';

describe('Tuple types', () => {
  const typeOutputDirectory = './src/__tests__/tuple/interfaces';

  beforeAll(() => {
    if (existsSync(typeOutputDirectory)) {
      rmdirSync(typeOutputDirectory, { recursive: true });
    }
  });

  test('tuple variations from file', async () => {
    const result = await convertFromDirectory({
      schemaDirectory: './src/__tests__/tuple/schemas',
      typeOutputDirectory
    });

    expect(result).toBe(true);

    const oneContent = readFileSync(`${typeOutputDirectory}/One.ts`).toString();

    expect(oneContent).toBe(
      `/**
 * This file was automatically generated by joi-to-typescript
 * Do not modify this file manually
 */

export interface Item {
  name: string;
}

/**
 * a test schema definition
 */
export interface Test {
  items?: [number, string, Item?] | null;
  name?: string;
  propertyName1: boolean;
}

/**
 * A tuple of Test object
 */
export type TestTuple = [
  /**
   * a test schema definition
   */
  Test,
  (number | string)?
];
`
    );
  });

  test("test to ensure can't use ordered and items both", () => {
    const schema = Joi.array()
      .ordered(Joi.string().description('one'))
      .items(Joi.number().description('two'))
      .required()
      .meta({ className: 'TestList' })
      .description('A list of Test object');

    const result = convertSchema({ sortPropertiesByName: true }, schema);
    expect(result).not.toBeUndefined;
    expect(result?.content).toBe(`/**
 * A list of Test object
 */
export type TestList = any[];`);
  });

  test('tuple newline', () => {
    const schema = Joi.object({
      name: Joi.string().optional(),
      propertyName1: Joi.bool().required(),
      items: Joi.array()
        .ordered(Joi.number().required())
        .ordered(Joi.string().required())
        .ordered(
          Joi.object({
            another: Joi.string()
          })
        )
        .allow(null),
      simpleItems: Joi.array().ordered(Joi.number().required()).ordered(Joi.string().required())
    })
      .meta({ className: 'Test' })
      .description('a test schema definition');

    const result = convertSchema({ sortPropertiesByName: true, tupleNewLine: true }, schema);
    expect(result).not.toBeUndefined;
    expect(result?.content).toBe(`/**
 * a test schema definition
 */
export interface Test {
  items?: [
      number,
      string,
      {
        another?: string;
      }?
    ] | null;
  name?: string;
  propertyName1: boolean;
  simpleItems?: [
    number,
    string
  ];
}`);
  });

  test('tuple and union newline', () => {
    const schema = Joi.object({
      name: Joi.string().optional(),
      propertyName1: Joi.bool().required(),
      items: Joi.array()
        .ordered(Joi.number().required())
        .ordered(Joi.string().required())
        .ordered(
          Joi.object({
            another: Joi.string()
          })
        )
        .allow(null)
    })
      .meta({ className: 'Test' })
      .description('a test schema definition');

    const result = convertSchema({ sortPropertiesByName: true, tupleNewLine: true, unionNewLine: true }, schema);
    expect(result).not.toBeUndefined;
    expect(result?.content).toBe(`/**
 * a test schema definition
 */
export interface Test {
  items?:
    | [
      number,
      string,
      {
        another?: string;
      }?
    ]
    | null;
  name?: string;
  propertyName1: boolean;
}`);
  });
});
